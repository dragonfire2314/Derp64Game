#include <ultra64.h>

#include "derp64.h"

/*
 * Symbol genererated by "make" to indicate the end of the code segment
 * in virtual (and physical) memory
 */
extern char _codeSegmentBssEnd[];

/*
 * Symbols generated by "make" to tell us where the static segment is
 * in ROM.
 */
extern char _staticSegmentRomStart[], _staticSegmentRomEnd[];

//Functions defines? I dont remember the term
static void idle(void *arg);
static void run(void *arg);

u64	bootStack[STACKSIZE/sizeof(u64)];

//Stacks and threads
static OSThread	idleThread;
static u64	idleThreadStack[STACKSIZE/sizeof(u64)];

static OSThread	mainThread;
static u64	mainThreadStack[STACKSIZE/sizeof(u64)];

OSPiHandle	*handler;

OSMesgQueue	rdpMessageQ;
OSMesg		rdpMessageBuf;

// OSTask	tlist =
// {
//     M_GFXTASK,			/* task type */
//     OS_TASK_DP_WAIT,		/* task flags */
//     NULL,			/* boot ucode pointer (fill in later) */
//     0,				/* boot ucode size (fill in later) */
//     NULL,			/* task ucode pointer (fill in later) */
//     SP_UCODE_SIZE,		/* task ucode size */
//     NULL,			/* task ucode data pointer (fill in later) */
//     SP_UCODE_DATA_SIZE,		/* task ucode data size */
//     &dram_stack[0],		/* task dram stack pointer */
//     SP_DRAM_STACK_SIZE8,	/* task dram stack size */
//     &rdp_output[0],		/* task fifo buffer start ptr */
//     &rdp_output[0]+RDP_OUTPUT_LEN, /* task fifo buffer end ptr */
//     NULL,			/* task data pointer (fill in later) */
//     0,				/* task data size (fill in later) */
//     NULL,			/* task yield buffer ptr (not used here) */
//     0				/* task yield buffer size (not used here) */
// };

enum {
  SP_STACK_SIZE = 1024,
};

static u64 sp_dram_stack[SP_STACK_SIZE / 8]
    __attribute__((align(16)));


static OSTask tlist = {{
    .type = M_GFXTASK,
    .flags = OS_TASK_DP_WAIT,
    .ucode = (u64 *)gspF3DEX2_xbusTextStart,
    .ucode_size = SP_UCODE_SIZE,
    .ucode_data = (u64 *)gspF3DEX2_xbusDataStart,
    .ucode_data_size = SP_UCODE_DATA_SIZE,
    .dram_stack = sp_dram_stack,
    .dram_stack_size = sizeof(sp_dram_stack),
}};

// Viewport scaling parameters.
Vp vp = {{
    .vscale = {SCREEN_WIDTH * 2, SCREEN_HEIGHT * 2, G_MAXZ / 2, 0},
    .vtrans = {SCREEN_WIDTH * 2, SCREEN_HEIGHT * 2, G_MAXZ / 2, 0},
}};

// Initialize the RSP.
Gfx rspinit_dl[] = {
    gsSPViewport(&vp),
    gsSPClearGeometryMode(G_SHADE | G_SHADING_SMOOTH | G_CULL_BOTH |
                          G_FOG | G_LIGHTING | G_TEXTURE_GEN |
                          G_TEXTURE_GEN_LINEAR | G_LOD),
    gsSPTexture(0, 0, 0, 0, G_OFF),
    gsSPEndDisplayList(),
};

// Initialize the RDP.
Gfx rdpinit_dl[] = { 
    gsDPSetCycleType(G_CYC_1CYCLE),
    gsDPSetScissor(G_SC_NON_INTERLACE, 0, 0, SCREEN_WIDTH,
                   SCREEN_HEIGHT),
    gsDPSetCombineKey(G_CK_NONE),
    gsDPSetAlphaCompare(G_AC_NONE),
    gsDPSetRenderMode(G_RM_NOOP, G_RM_NOOP2),
    gsDPSetColorDither(G_CD_DISABLE),
    gsDPPipeSync(),
    gsSPEndDisplayList(),
};

// Clear the color framebuffer.
Gfx clearframebuffer_dl[] = {
    gsDPSetCycleType(G_CYC_FILL),
    gsDPSetColorImage(G_IM_FMT_RGBA, G_IM_SIZ_16b, SCREEN_WIDTH, rsp_cfb),
    gsDPPipeSync(),
    gsDPSetFillColor(GPACK_RGBA5551(255,0,0,1)<<16 | GPACK_RGBA5551(255,0,0,1)),
    gsDPFillRectangle(0, 0, SCREEN_WIDTH - 1, SCREEN_HEIGHT - 1),
    gsSPEndDisplayList(),
};

void boot() 
{
    osInitialize();

    handler = osCartRomInit();

    osCreateThread(&idleThread, 1, idle, (void*) 0, idleThreadStack+STACKSIZE/sizeof(u64), 10);
    osStartThread(&idleThread);
}

static void idle(void *arg)
{
    /* Initialize video */
    osCreateViManager(OS_PRIORITY_VIMGR);
    osViSetMode(&osViModeTable[OS_VI_NTSC_LAN1]);
    
    /*
     * Create main thread
     */
    osCreateThread(&mainThread, 3, run, NULL,
		   mainThreadStack+STACKSIZE/sizeof(u64), 10);
    osStartThread(&mainThread);

    /*
     * Become the idle thread
     */
    osSetThreadPri(0, 0);

    for(;;);
}

static void run(void *arg) 
{
    osCreateMesgQueue(&rdpMessageQ, &rdpMessageBuf, 1);
    osSetEventMesg(OS_EVENT_DP, &rdpMessageQ, NULL);

    tlist.t.ucode_boot = (u64*)rspbootTextStart;
    tlist.t.ucode_boot_size = (u32)rspbootTextEnd - (u32)rspbootTextStart;
    
    // for (int i = 0; i < 10000; i++) {
    //     rsp_cfb[i] = 0x444F; 
    // }

    while (1) 
    {
        Gfx glist[16], *glistp = glist;
        gSPSegment(glistp++, 0, 0);
        gSPDisplayList(glistp++, rdpinit_dl);
        gSPDisplayList(glistp++, rspinit_dl);
        clearframebuffer_dl[1] = (Gfx)gsDPSetColorImage(G_IM_FMT_RGBA, G_IM_SIZ_16b, SCREEN_WIDTH, rsp_cfb);
        gSPDisplayList(glistp++, clearframebuffer_dl);
        gDPFullSync(glistp++);
        gSPEndDisplayList(glistp++);

        osWritebackDCache(&clearframebuffer_dl[1], sizeof(Gfx) * 3);
        osWritebackDCache(glist, sizeof(*glist) * (glistp - glist));
        tlist.t.data_ptr = (u64 *)glist;
        tlist.t.data_size = sizeof(*glist) * (glistp - glist);

        osSpTaskStart(&tlist);
        osRecvMesg(&rdpMessageQ, NULL, OS_MESG_BLOCK);
    }
}