#include <ultra64.h>

#include "derp64.h"
#include "pumpkin.h"
#include "cube.h"

/*
 * Symbol genererated by "make" to indicate the end of the code segment
 * in virtual (and physical) memory
 */
extern char _codeSegmentBssEnd[];

/*
 * Symbols generated by "make" to tell us where the static segment is
 * in ROM.
 */
extern char _staticSegmentRomStart[], _staticSegmentRomEnd[];

//Functions defines? I dont remember the term
static void idle(void *arg);
static void run(void *arg);

u64	bootStack[STACKSIZE/sizeof(u64)];

//Stacks and threads
static OSThread	idleThread;
static u64	idleThreadStack[STACKSIZE/sizeof(u64)];

static OSThread	mainThread;
static u64	mainThreadStack[STACKSIZE/sizeof(u64)];

OSPiHandle	*handler;

/* this number (the depth of the message queue) needs to be equal
 * to the maximum number of possible overlapping PI requests.
 */
#define NUM_PI_MSGS     8

static OSMesg PiMessages[NUM_PI_MSGS];
static OSMesgQueue PiMessageQ;


OSMesgQueue	dmaMessageQ, rdpMessageQ, retraceMessageQ;
OSMesg		dmaMessageBuf, rdpMessageBuf, retraceMessageBuf;
OSIoMesg	dmaIOMessageBuf;

OSTask	tlist =
{
    M_GFXTASK,			/* task type */
    OS_TASK_DP_WAIT,		/* task flags */
    NULL,			/* boot ucode pointer (fill in later) */
    0,				/* boot ucode size (fill in later) */
    NULL,			/* task ucode pointer (fill in later) */
    SP_UCODE_SIZE,		/* task ucode size */
    NULL,			/* task ucode data pointer (fill in later) */
    SP_UCODE_DATA_SIZE,		/* task ucode data size */
    &dram_stack[0],		/* task dram stack pointer */
    SP_DRAM_STACK_SIZE8,	/* task dram stack size */
    &rdp_output[0],		/* task fifo buffer start ptr */
    &rdp_output[0]+RDP_OUTPUT_LEN, /* task fifo buffer end ptr */
    NULL,			/* task data pointer (fill in later) */
    0,				/* task data size (fill in later) */
    NULL,			/* task yield buffer ptr (not used here) */
    0				/* task yield buffer size (not used here) */
};

Gfx glist[2048];


struct graphics {
    Mtx projection;
    Mtx camera;
    Mtx model;
    Mtx rotate_y;
    Mtx rotate_x;
};

struct graphics gr;

// static OSTask tlist = {{
//     .type = M_GFXTASK,
//     .flags = OS_TASK_DP_WAIT,
//     .ucode = (u64 *)gspF3DEX2_xbusTextStart,
//     .ucode_size = SP_UCODE_SIZE,
//     .ucode_data = (u64 *)gspF3DEX2_xbusDataStart,
//     .ucode_data_size = SP_UCODE_DATA_SIZE,
//     .dram_stack = sp_dram_stack,
//     .dram_stack_size = sizeof(sp_dram_stack),
// }};

static int      draw_buffer = 0;
static float	theta = 0.0;

void boot() 
{
    osInitialize();

    handler = osCartRomInit();

    osCreateThread(&idleThread, 1, idle, (void*) 0, idleThreadStack+STACKSIZE/sizeof(u64), 10);
    osStartThread(&idleThread);
}

static void idle(void *arg)
{
    /* Initialize video */
    osCreateViManager(OS_PRIORITY_VIMGR);
    osViSetMode(&osViModeTable[OS_VI_NTSC_LAN1]);
    
    /*
     * Start PI Mgr for access to cartridge
     */
    osCreatePiManager((OSPri)OS_PRIORITY_PIMGR, &PiMessageQ, PiMessages, 
		      NUM_PI_MSGS);

    /*
     * Create main thread
     */
    osCreateThread(&mainThread, 3, run, NULL,
		   mainThreadStack+STACKSIZE/sizeof(u64), 10);
    osStartThread(&mainThread);

    /*
     * Become the idle thread
     */
    osSetThreadPri(0, 0);

    for(;;);
}

Dynamic dynamic;

static void run(void *arg) 
{
    char *staticSegment;
    OSTask *tlistp;

    /*
     * Setup the message queues
     */
    osCreateMesgQueue(&dmaMessageQ, &dmaMessageBuf, 1);
    
    osCreateMesgQueue(&rdpMessageQ, &rdpMessageBuf, 1);
    osSetEventMesg(OS_EVENT_DP, &rdpMessageQ, NULL);
    
    osCreateMesgQueue(&retraceMessageQ, &retraceMessageBuf, 1);
    osViSetEvent(&retraceMessageQ, NULL, 1);
    
    /*
     * Stick the static segment right after the code/data segment
     */
    staticSegment = _codeSegmentBssEnd;

    dmaIOMessageBuf.hdr.pri      = OS_MESG_PRI_NORMAL;
    dmaIOMessageBuf.hdr.retQueue = &dmaMessageQ;
    dmaIOMessageBuf.dramAddr     = staticSegment;
    dmaIOMessageBuf.devAddr      = (u32)_staticSegmentRomStart;
    dmaIOMessageBuf.size         = (u32)_staticSegmentRomEnd-(u32)_staticSegmentRomStart;

    osEPiStartDma(handler, &dmaIOMessageBuf, OS_READ);
    
    /*
     * Wait for DMA to finish
     */
    (void)osRecvMesg(&dmaMessageQ, NULL, OS_MESG_BLOCK);




    tlist.t.ucode_boot = (u64*)rspbootTextStart;
    tlist.t.ucode_boot_size = (u32)rspbootTextEnd - (u32)rspbootTextStart;

    tlist.t.ucode = (u64 *) gspF3DEX2_xbusTextStart;
	tlist.t.ucode_data = (u64 *) gspF3DEX2_xbusDataStart;
    
    // for (int i = 0; i < 10000; i++) {
    //     rsp_cfb[i] = 0x444F; 
    // }

    while (1) 
    {
        tlistp = &tlist;

        Gfx *glistp = glist;

        Dynamic	*dynamicp;
        dynamicp = &dynamic;

        guOrtho(&dynamicp->projection,
            -(float)SCREEN_WIDTH/2.0F, (float)SCREEN_WIDTH/2.0F, 
            -(float)SCREEN_HEIGHT/2.0F, (float)SCREEN_HEIGHT/2.0F,
            1.0F, 10.0F, 1.0F);
	    guRotate(&dynamicp->modeling, theta, 0.0F, 0.0F, 1.0F);

        gSPSegment(glistp++, 0, 0x0);	/* Physical address segment */
	    gSPSegment(glistp++, STATIC_SEGMENT, OS_K0_TO_PHYSICAL(staticSegment));
	    gSPSegment(glistp++, CFB_SEGMENT, OS_K0_TO_PHYSICAL(cfb[draw_buffer]));

        gSPDisplayList(glistp++, rdpinit_dl);
        gSPDisplayList(glistp++, rspinit_dl);

        gSPDisplayList(glistp++, clearframebuffer_dl);

        gSPDisplayList(glistp++, sprite_dl);


        

        
        // gSPDisplayList(glistp++, shadetri_dl);






        gDPFullSync(glistp++);
        gSPEndDisplayList(glistp++);

        osWritebackDCache(glist, sizeof(*glist) * (glistp - glist));
        tlist.t.data_ptr = (u64 *)glist;
        tlist.t.data_size = sizeof(*glist) * (glistp - glist);

        osSpTaskStart(&tlist);
        osRecvMesg(&rdpMessageQ, NULL, OS_MESG_BLOCK);

        //Print a Image
        

        /* setup to swap buffers */
        osViSwapBuffer(cfb[draw_buffer]);

        /* Make sure there isn't an old retrace in queue 
        * (assumes queue has a depth of 1) 
        */
        if (MQ_IS_FULL(&retraceMessageQ))
            (void)osRecvMesg(&retraceMessageQ, NULL, OS_MESG_BLOCK);
        
        /* Wait for Vertical retrace to finish swap buffers */
        (void)osRecvMesg(&retraceMessageQ, NULL, OS_MESG_BLOCK);
        draw_buffer ^= 1;
    }
}